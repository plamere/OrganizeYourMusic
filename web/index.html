<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">
    <link href="https://sp-bootstrap.global.ssl.fastly.net/7.4.1/sp-bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
    <link href="//cdnjs.cloudflare.com/ajax/libs/x-editable/1.5.0/bootstrap3-editable/css/bootstrap-editable.css" rel="stylesheet"/>
    <link rel="stylesheet" href="styles2.css" rel="stylesheet" />

    <title>Organize Your Music</title>
    <!-- Custom styles for this template -->
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
  <body >
    <div id="navbar" class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">
            <span class="navbar-title">Organize Your Music</span>
          </a>
        </div>
       <div class="nav  navbar-nav navbar-right">
           <span id="info" class="navbar-info navbar-right"></span>
        </div>
      </div>
    </div>

    <!-- Main jumbotron for a primary marketing message or call to action -->
      <div id='intro'>
      <div id='main' class="top jumbotron jumbotron-hero container-fluid">
          <div  class="container" id="jumbo-dialog">
            <h1 id='ttitle' >Organize Your Music</h1>
            <p id='ttext'>
                Organize your Spotify music collection
                by any of a wide range of musical attributes including
                genre, mood, decade of release and more.
            </p>

            <div class='col-xs-offset-3 col-xs-6 form-group'>
                <label id="what-label" for="collection-type"> What do you want to organize: </label>
                <select id="collection-type" class="form-control">
                    <option value='saved'> Songs you've saved to Your Music</option>
                    <option value='added'> Songs you've added to a playlist</option>
                    <option value='follow'> Songs in playlists you follow </option>
                    <option value='all'> All of your music</option>
                    <option value='playlist'> A specific playlist</option>
                </select>

                <div id="uri-prompt" class="input-group align-center">
                    <span for="uri-text"> Enter the URI for your playlist:</span>
                    <input id="uri-text" type="text" class='form-control' 
                        placeholder="spotify:user:spotify:playlist:5FJXhjdILmRA2z5bvz4nzf">
                </div>

                <br>
                <a class="btn btn-primary btn-lg go" id='go' role="button">Organize your music</a>
                <p> </p>
            </div>
            <div class='err-txt'> </div>
          </div>
      </div>

        <div class="container ">
          <div class="row features">
             <div class="col-md-offset-2 col-md-8">
                    <h2 class="text-center">Get your music collection in order</h2>
                    <p>
                    With <b> Organize Your Music </b> you can easily organize
                    your saved music. Just follow these steps:
                    </p>
                    <ol>
                        <li> <b> Select  </b> what music you'd
                        like to organize: Your Saved Music; Music you've added
                        to playlists; Music in playlists you follow; or all of
                        it.
                        <li> <b> Click </b> on <i>Organize your Music</i>.
                        If this is your first visit, you will be asked to ...
                        <li>  <b> Login </b> with your Spotify
                        credentials. <b> Organize Your Music</b> will place all
                        of your tracks into a number of bins. There are Genres,
                        Moods, Decades, Popularity and more.
                        <li>  <b> Pick </b> one of the bins. You can view
                        all the properties of the tracks in that bin. You can
                        plot the tracks.  You can listen
                        to previews of the songs in the bin. 
                        <li>  <b> Select </b> tracks that you want to add to a
                        playlist. Selected tracks will be added to
                        your <b> Staging Playlist</b>. When you are happy with
                        the staging playlist you can 
                        <li>  <b> Save </b> the staging playlist to Spotify.
                    </ol>
                    <p> Don't worry. <b> Organize Your Music </b> will never modify any of
                    the songs in your saved music or playlists. It will only save
                    new playlists for you, and only when you explictly click on
                    the <b> save </b> button.

                    <h2> The  Track Properties </h2>
                    Organize Your Music can help you slice and dice your music
                    collection by a wide range of properties:

                    <ol>
                        <li> <b> Genre </b> - the genre of the track
                        <li> <b> Year </b> - the release year of the recording.
                        Note that due to vagaries of releases, re-releases,
                        re-issues and general madness, sometimes the release
                        years are not what you'd expect.
                        <li> <b> Added </b> - the earliest date you added 
                        the track to your collection.
                        <li> <b> Beats Per Minute (BPM)</b> - The tempo of the
                        song.
                        <li> <b> Energy</b> - The energy of a song - the higher
                        the value, the more energtic.
                        song
                        <li> <b> Danceability</b> - The higher the value, the
                        easier it is to dance to this song.
                        <li> <b> Loudness (dB)</b> - The higher the value, the
                        louder the song.
                        <li> <b> Liveness </b> - The higher the value, the
                        more likely the song is a live recording.
                        <li> <b> Valence </b> - The higher the value, the
                        more positive mood for the song.
                        <li> <b> Length </b> - The duration of the song.
                        <li> <b> Acousticness </b> - The higher the value the more
                        acoustic the song is.
                        <li> <b> Speechiness </b> - The higher the value the more
                        spoken word the song contains.
                        <li> <b> Popularity </b> - The higher the value the more
                        popular the song is.
                        <li> <b> Duration </b> - The length of the song.
                    </ol>
                    </p>
                    <h2> See it in Action</h2>
                    Here's a demo of how I use Organize Your Music to make
                    a playlist of my most energtic gothic metal.

                    <p>
                    <iframe width="640" height="360"
                    src="https://www.youtube.com/embed/NGY1cthhr5g"
                    frameborder="0" allowfullscreen></iframe>
                     
              </div>

          </div>
        </div>
        </div>

  <div class="row">
  <div id="sidebar" class="sidebar work"> </div>

  <div id="main-wrapper">
      <div class="work" id="main-area">
          <div id="loading">
            <h3 id="section-title" class="ntext-center"></h3>
            <div id="loading-header">
                <h4 id="lplaylist-name" class="ntext-center"></h4>
                <div id="linfo"> </div>
                <div id='tiny-track'> </div>
                <div class="progress">
                   <div id="progress-bar" class="progress-bar" role="progressbar"
                        aria-valuenow="00" aria-valuemin="0" aria-valuemax="100" style="width: 0%;">
                      <span class="sr-only">00% Complete</span> </div>
                </div>
            </div>
            <button id='stop-loading' class='btn btn-xs btn-default'> Stop </button>
             <div class='loading-text'>
                We are loading up all of your music. This may take a while
                depending upon how big your music collection is.  If you are
                impatient, you can stop the loading at anytime to work with a
                subset of your music.
                </p>
            </div>
            <div id="favs" class='loading-text'>
                Looks like you really enjoy your <span class="fav-text" id='fav-genre'> </span>
                and <span class="fav-text" id="fav-artist"> </span>.  It seems like one of your
                favorite songs is <span class="fav-text" id="fav-song"></span>.
            </div>

            <!--
            <div id="recency" class='loading-text'>
                One of the first traks you ever added to your music is
                <span class="fav-text" id='fav-oldest-song'> </span>.
                One of the most recent tracks you've added to your music is
                <span class="fav-text" id='fav-newest-song'> </span>.
            </div>
            -->
          </div>
          <div id="loaded">
            <div id="exTab3" class="ccontainer">    
                <ul  class="nav nav-tabs"> 
                    <li class="active"> <a  id='the-track-list-tab' href="#the-track-list" 
                            data-toggle="tab">The Track list</a> </li>
                    <li><a href="#the-plots" data-toggle="tab">The Plots</a> </li>
                    <li><a href="#staging" id='staging-tab'
                    data-toggle="tab">Staging Playlist (<span
                    class='nstaging-tracks'>0</span>)</a> </li>
                </ul>


                <div class="tab-content clearfix">
                  <div class="tab-pane active" id="the-track-list">
                    <h4 id="playlist-title" class="ntext-center"></h4>
                      <table id="gthe-track-table" class="table ntable-striped table-responsive"> </table>
                      <div id="gthe-track-table-truncated"> Showing the first <span class="max-shown"> </span> matching tracks. </div>
                   </div>

                    <div class="tab-pane" id="the-plots">
                        <div class="row" id="plot-controls">
                            <div class="col-xs-3">
                                <span for="select-size"> X axis: </span> <br>
                                <select id='select-xaxis' class="axis-select nform-control nselectpicker"> </select>
                            </div>

                            <div class="col-xs-3">
                                <span for="select-size"> Y axis:</span> <br>
                                <select id='select-yaxis' class="axis-select nform-control nselectpicker"> </select>
                            </div>

                            <div class="col-xs-3">
                                <span for="select-size"> Size: </span> <br>
                                <select id='select-size' class="axis-select nform-control nselectpicker"> </select>
                            </div>
                            <div id='plot-buttons' class="col-xs-1">
                                <!--
                                <a id="plot-select" title="add selected tracks to staging" 
                                class="nbtn btn-success">
                                <span class="glyphicon glyphicon-ok"></span></a>
                                -->
                                <a id="plot-clear" title="clear all tracks from the plot"
                                class="nbtn btn-danger"><span
                                class="glyphicon glyphicon-trash"></span></a>
                            </div>
                        </div>
                        <div id="the-plot"></div>
                    </div>

                  <div class="tab-pane" id="staging">
                    <div id="staging-empty">
                        <div>
                            <h3> The Staging Playlist (<span
                            class='nstaging-tracks'>0</span>)</h3>
                            This is the <b> Staging Playlist </b>.  This is
                            where you collect the tracks that you want to save
                            to a particular playlist. There's nothing here yet.
                            To add tracks to this staging playlist head back to
                            <b>The Track List </b> or <b> The Plots </b> and
                            select some tracks. Selected tracks will
                            automatically be added here.
                            <h4> Adding tracks via The Track list </h4>
                            To add tracks from the track list, click on the
                            track list tab to show the track list, and then
                            click on categories of interest in the left sidebar.
                            Tracks in the category will be displayed in the
                            track list.  To add tracks of interest to the staging
                            list, click on the <i>sel</i> checkbox for those
                            tracks.
                            <br>
                            <img width="400" src='images/select-example.png'>

                            <h4> Adding tracks via The Plots </h4>
                            To add tracks from the plot list, click on the The
                            Plots tab to show the plots. Add tracks to the plot
                            by clicking on categories of interest in the left
                            sidebar. Tracks in the category will be displayed in
                            the plot.  You can then use one of the plot select
                            tools to select particular tracks from the plot to
                            add to the staging list.
                            <br>
                            <img width="800" src='images/plot-select.png'>
                        </div>
                    </div>
                    <div id="staging-full">
                        <a href="#" id="staging-playlist-name" data-type="text" data-pk="1" 
                             data-title="Enter the staging playlist name">Your new playlist</a> 
                            <h4 id="save-button" class="pull-right"><a><span  
                            class="glyphicon glyphicon-save"></span>Save Playlist</a></h4>
                          <div> </div>
                          <table id="gthe-staging-table" class="table table-responsive"> </table>
                          <div id="gthe-staging-table-truncated"> Showing the first 400 matching tracks. </div>
                     </div>
                   </div>
                </div>
            </div>

              <br>
          </div>
      </div>
    </div>

    <div style="clear:both"> </div>
    <div id="footer">
      <div class="container text-center">
            <p class="text-muted">
                Powered by the <a href="http://spotify.com">Spotify API</a>.
                Created by <a href="http://twitter.com/plamere">@plamere</a>
                at <a href="http://labrosa.ee.columbia.edu/hamr_ismir2016/">The
                Science of Music Hackathon in NYC on Aug 6, 2016</a>.
                Get the <a
                href="https://github.com/plamere/OrganizeYourMusic">source</a>.
            </p>
      </div>
    </div>
    <script src="lib/jquery-1.11.1.min.js"></script>
    <script src="lib/moment.min.js"></script>
    <script src="https://sp-bootstrap.global.ssl.fastly.net/7.4.1/sp-bootstrap.min.js"></script>
    <script src="lib/underscore-min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/x-editable/1.5.0/bootstrap3-editable/js/bootstrap-editable.min.js"></script>
    <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
    <script type="text/javascript" charset="utf-8" src="lib/rsvp-latest.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="config.js?v3"></script>

<script>
"use strict";
var accessToken = null;
var curUserID = null;
var curTracks = {};
var curArtists = {};
var curAlbums = {};
var curTypeName = null;
var curSelected = new Set();
var curSelectedTracks = [];
var nodeMap = { }
var genreIndex = 0;
var sourceIndex = 7;
var thePlot = null;

var skipGenrePhrases = ['christmas'];
var audio = $("<audio>");
var nowPlaying = null;
var curNode = null;
var abortLoading = false;

var progressBar = $("#progress-bar");

var topArtistCount = 0;
var totalTracks = 0;
var topArtistName = null;
var topTrackName = null;
var topTrackCount = 0;
var totalPlaylists = 0;
var processedPlaylists = 0;
var theTrackTable =  null;
var theStagingTable =  null;
var stagingIsVisible = false;
var maxTracksShown = 5000;



RSVP.on('error', function(reason) {
  console.assert(false, reason);
});


var theWorld = [
    {
        name: "Genres",
        nodes: [ ],
    },
    {
        name: "Moods",
        nodes: [
            makeNode("(unclassified mood)", "popularity", featMissingFilter('energy'),
                                        featGetterInt('popularity'),
                                        featSorter('popularity', true), true),
            makeNode("chill", "energy", featMusicFilter('energy', 0, .2),
                                        featGetterPercent('energy'),
                                        featSorter('energy', false), true),
            makeNode("amped", "energy", featMusicFilter('energy', .8, 1.0),
                                        featGetterPercent('energy'),
                                        featSorter('energy', true), true),
            makeNode("sad", "sadness", featMusicFilter('sadness', .8, 1.0),
                                        featGetterPercent('sadness'),
                                        featSorter('sadness', true), true),
            makeNode("anger", "anger", featMusicFilter('anger', .8, 1.0),
                                        featGetterPercent('anger'),
                                        featSorter('anger', true), true),
            makeNode("happy", "happiness", featMusicFilter('happiness', .8, 1.0),
                                        featGetterPercent('happiness'),
                                        featSorter('happiness', true), true),
            makeNode("danceable", "danceability", featMusicFilter('danceability', .8, 1.0),
                                        featGetterPercent('danceability'),
                                        featSorter('danceability', true), true),
        ]
    },
    {
        name: "Styles",
        nodes: [
            makeNode("instrumental", "instrumentalness",
                featMusicFilter('instrumentalness', .8, 1.0),
                featGetterPercent('instrumentalness'),
                featSorter('instrumentalness', true), true),
            makeNode("acoustic", "acousticness",
                featMusicFilter('acousticness', .8, 1.0),
                featGetterPercent('acousticness'),
                featSorter('acousticness', true), true),
            makeNode("live", "liveness",
                featMusicFilter('liveness', .85, 1.0),
                featGetterPercent('liveness'),
                featSorter('liveness', true), true),
            makeNode("spoken word", "speechiness",
                featFilter('speechiness', .85, 1.0),
                featGetterPercent('speechiness'),
                featSorter('speechiness', true), true),
            makeNode("clean", "explicit",
                featBoolFilter('explicit', false),
                featGetterBool('explicit', 'explicit', 'clean'),
                featSorter('explicit', true), false),

            makeNode("explicit", "explicit",
                featBoolFilter('explicit', true),
                featGetterBool('explicit', 'explicit', 'clean'),
                featSorter('explicit', true), false),
            makeNode("loud", "loudness (dB)",
                featMusicFilter('loudness', -5, 0),
                featGetterInt('loudness'),
                featSorter('loudness', true), true),
            makeNode("quiet", "loudness (dB)",
                featMusicFilter('loudness', -60, -10),
                featGetterInt('loudness'),
                featSorter('loudness', false), true),
        ]
    },
    {
        name: "Decades",
        nodes: [
            makeNode("Oldies", "year",
                featFilter('year', 0, 1950),
                featGetter('year'),
                featSorter('year', false), true),
            makeNode("1950s", "year",
                featFilter('year', 1950, 1959),
                featGetter('year'),
                featSorter('year', false), true),
            makeNode("1960s", "year",
                featFilter('year', 1960, 1969),
                featGetter('year'),
                featSorter('year', false), true),
            makeNode("1970s", "year",
                featFilter('year', 1970, 1979),
                featGetter('year'),
                featSorter('year', false), true),
            makeNode("1980s", "year",
                featFilter('year', 1980, 1989),
                featGetter('year'),
                featSorter('year', false), true),
            makeNode("1990s", "year",
                featFilter('year', 1990, 1999),
                featGetter('year'),
                featSorter('year', false), true),
            makeNode("2000s", "year",
                featFilter('year', 2000, 2009),
                featGetter('year'),
                featSorter('year', false), true),
            makeNode("2010s", "year",
                featFilter('year', 2010, 2019),
                featGetter('year'),
                featSorter('year', false), true),
            makeNode("Now", "year",
                featFilter('year', 2016, 2020),
                featGetter('year'),
                featSorter('year', false), true),
            makeNode("(unclassified year)", "year",
                featFilter('year', -1, 0),
                featGetter('year'),
                featSorter('year', false), false),
        ]
    },
    {
        name: "Added",
        nodes: [
            makeNode("Today", "age (days)",
                featFilter('age', 0, 1),
                featGetterInt('age'),
                featSorter('age', false), true),
            makeNode("In the last week", "age (days)",
                featFilter('age', 0, 7),
                featGetterInt('age'),
                featSorter('age', false), true),
            makeNode("In the last month", "age (days)",
                featFilter('age', 0, 30),
                featGetterInt('age'),
                featSorter('age', false), true),
            makeNode("In the last year", "age (days)",
                featFilter('age', 0, 365),
                featGetterInt('age'),
                featSorter('age', false), true),
            makeNode("Over a year ago", "age (days)",
                featFilter('age', 356, 365 * 100),
                featGetterInt('age'),
                featSorter('age', false), true),
            makeNode("Over 2 years ago", "age (days)",
                featFilter('age', 356 * 2, 365 * 100),
                featGetterInt('age'),
                featSorter('age', false), true),
            makeNode("Over 5 years ago", "age (days)",
                featFilter('age', 356 * 5, 365 * 100),
                featGetterInt('age'),
                featSorter('age', false), true),
            makeNode("Whenever", "age (days)",
                featFilter('age', 0, 365 * 100),
                featGetterInt('age'),
                featSorter('age', false), true),
        ]
    },
    {
        name: "Popularity",
        nodes: [
            makeNode("top popular", "Popularity",
                featFilter('popularity', 75, 100),
                featGetter('popularity'),
                featSorter('popularity', true), true),
            makeNode("very popular", "Popularity",
                featFilter('popularity', 50, 75),
                featGetter('popularity'),
                featSorter('popularity', true), true),
            makeNode("somewhat popular", "Popularity",
                featFilter('popularity', 20, 50),
                featGetter('popularity'),
                featSorter('popularity', true), true),
            makeNode("deep", "Popularity",
                featFilter('popularity', 0, 20),
                featGetter('popularity'),
                featSorter('popularity', true), true),
        ]
    },

    {
        name: "Duration",
        nodes:[
            /*
            makeNode("0 to 1 minute", "Duration",
                featFilter('duration_ms', mins(0), mins(1)),
                featGetter('duration_ms'),
                featSorter('duration_ms', false), true),
            makeNode("1 to 2 minute", "Duration",
                featFilter('duration_ms', mins(1), mins(2)),
                featGetter('duration_ms'),
                featSorter('duration_ms', false), true),

            makeNode("2 to 3 minute", "Duration",
                featFilter('duration_ms', mins(2), mins(3)),
                featGetter('duration_ms'),
                featSorter('duration_ms', false), true),

            makeNode("3 to 5 minute", "Duration",
                featFilter('duration_ms', mins(3), mins(5)),
                featGetter('duration_ms'),
                featSorter('duration_ms', false), true),

            makeNode("4 to 8 minute", "Duration",
                featFilter('duration_ms', mins(4), mins(8)),
                featGetter('duration_ms'),
                featSorter('duration_ms', false), true),
            */
            makeNode("Very very short", "Duration",
                featFilter('duration_ms', mins(0), mins(.5)),
                featGetter('duration_ms'),
                featSorter('duration_ms', false), true),

            makeNode("Very short", "Duration",
                featFilter('duration_ms', mins(0), mins(1.5)),
                featGetter('duration_ms'),
                featSorter('duration_ms', false), true),

            makeNode("Short", "Duration",
                featFilter('duration_ms', mins(0), mins(3)),
                featGetter('duration_ms'),
                featSorter('duration_ms', false), true),

            makeNode("Medium", "Duration",
                featFilter('duration_ms', mins(3), mins(6)),
                featGetter('duration_ms'),
                featSorter('duration_ms', false), true),

            makeNode("Long", "Duration",
                featFilter('duration_ms', mins(6), mins(1000)),
                featGetter('duration_ms'),
                featSorter('duration_ms', false), true),

            makeNode("Very long", "Duration",
                featFilter('duration_ms', mins(12), mins(1000)),
                featGetter('duration_ms'),
                featSorter('duration_ms', false), true),

            makeNode("Very very long", "Duration",
                featFilter('duration_ms', mins(30), mins(1000)),
                featGetter('duration_ms'),
                featSorter('duration_ms', false), true),
        ]
    },

    {
        name: "Sources",
        nodes: [ ],
    },
];

function mins(min) {
    return min * 60 * 1000;
}
    


function now() {
    return new Date().getTime();
}

function updateFavs() {
    if (theWorld[genreIndex].nodes.length > 0 && topArtistName && topTrackName) {
        var favGenre = theWorld[genreIndex].nodes[0].name
        $("#fav-genre").text(favGenre);
        $("#fav-artist").text(topArtistName);
        $("#fav-song").text(topTrackName);
        $("#favs").show();
    }
}

function refreshHeader() {
    var ntracks = Object.keys(curTracks).length;
    var nArtists = Object.keys(curArtists).length;
    if (totalPlaylists > 0) {
        linfo("Found " + ntracks + " unique tracks  by " + nArtists
        + " artists in " + processedPlaylists + " of "
        + totalPlaylists + " playlists");
        var progress =  processedPlaylists * 100 / totalPlaylists;
        setProgress(progress);
    } else {
        if (totalTracks > 0) {
            var progress =  ntracks * 100 / totalTracks;
            setProgress(progress);
        }
        linfo("Found " + ntracks + " tracks  by "
        + nArtists + " artists in your collection.");
    }
}

function addTracks(tracks) {
    _.each(tracks, function(track) {
        var genres = getGenresForTrack(track);
        track.feats.genres = new Set();
        track.feats.topGenre = "";
        _.each(genres, function(genre) {
            if (isGoodGenre(genre)) {
                track.feats.genres.add(genre);
                if (track.feats.topGenre.length == 0 && genre !== '(unclassified genre)') {
                    track.feats.topGenre = genre;
                }
                if (!(genre in nodeMap) ) {
                    var node = makeNode(genre, "Genre",
                            featGenreFilter(genre),
                            featGenreGetter(genre),
                            featSorter('popularity', true), false);
                    theWorld[genreIndex].nodes.push(node);
                }
                if (!(track.feats.source in nodeMap)) {
                    var node = makeNode(track.feats.source, "Source",
                            featSourceFilter(track.feats.source),
                            featSourceGetter(track.feats.source),
                            featSorter('popularity', true), false);
                    theWorld[sourceIndex].nodes.push(node);
                }
            }
        });

        track.feats.year = getYearForTrack(track);
    });
}

function filterTracks(tracks) {
    _.each(theWorld, function(bin) {
        _.each(bin.nodes, function(node) {
            _.each(applyFilter(tracks, node.filter), function(track) {
                node.tracks.push(track);
                node.artists.add(track.details.artists[0].id);
            });
        });
    });

    _.each(tracks, function(track) {
        saveTrack(track);
    });
}

var totRefresh = 0;

function refreshTheWorld(quick) {
    var start = now();
    if (!quick) {
        //collapseGenres();
    }
    updateViewOfTheWorld(quick);
    var delta = now() - start;
    totRefresh += delta;
}

// needs some more thought
function collapseGenres() { 
    var nodes = theWorld[genreIndex].nodes;
    var used = new Set();
    sortedNodes(nodes);
    var keep = [];

    _.each(theWorld[genreIndex].nodes, function(node) {
        var count = 0;
        _.each(node.tracks, function(track) {
            if (!used.has(track.id)) {
                used.add(track.id);
                count += 1;
            }
        });
        if (count > 0) {
            keep.push(node);
        } else {
        }
    });
    theWorld.push( 
        {
            name:"Collapsed Genres",
            nodes:keep
        }
    );
}


function playlistSubtitle(s) {
    $("#playlist-sub-title").text(s);
}

function playlistTitle(s) {
    $("#playlist-title").text(s);
}



var curPlottingNodes = {}
var curPlottingNames = [];

function getPlotData(node) {
    var xDataName = $("#select-xaxis").val();
    var yDataName = $("#select-yaxis").val();

    var theDataTrace = {
        x:[],
        y:[],
        mode: 'markers',
        name: node.name,
        text: [],
        node:node,
        marker: {
            sizemode:'diameter',
            size:[],
            sizeref:1,
            sizemin:2,
        }
    };
    var xGetter = plottableData[xDataName].getter;
    var yGetter = plottableData[yDataName].getter;

    var sizes = [];
    _.each(node.tracks, function(track) {
        theDataTrace.x.push(xGetter(track));
        theDataTrace.y.push(yGetter(track));
        var name = track.details.name + " - " + track.details.artists[0].name;
        theDataTrace.text.push(name);
    });

    var nsizes = normalizeSizes(node.tracks);
    theDataTrace.marker.size = nsizes;
    return theDataTrace;
}

function normalizeSizes(tracks) {
    var sizeDataName = $("#select-size").val();
    var sizeInfo = plottableData[sizeDataName];
    var minWidth = 4;
    var maxWidth = 12;
    var minSize = sizeInfo.min;
    var maxSize = sizeInfo.max;
    var out = [];
    var range = maxSize - minSize;
    var orange = maxWidth - minWidth;
    _.each(tracks, function(track) {
        var val = sizeInfo.getter(track);
        if (val < minSize) {
            val = minSize;
        }
        if (val > maxSize) {
            val = maxSize;
        }
        var nval = (val - minSize) / range;
        var oval = nval * orange + minWidth;
        out.push(oval);
    });
    return out;
}

function plotPlaylist(node) {
    if ( (node.name in curPlottingNodes)) {
        delete curPlottingNodes[node.name]; 
        redrawPlot();
    } else {
        curPlottingNodes[node.name] = node;
        curPlottingNames.push(node.name);
        Plotly.plot(thePlot, [getPlotData(node)], getLayout());
    }
}

function getLayout() {
    var xDataName = $("#select-xaxis").val();
    var yDataName = $("#select-yaxis").val();
    var sizeDataName = $("#select-size").val();
    var xMargin = 300;
    var yMargin = 200;
    var yFooter = 20;
    var minHeight = 300;
    var minWidth = 600;

    var width =   $(window).width() - xMargin;
    if (width < minWidth) {
        width = minWidth;
    }
    var height =   $(window).height() - yMargin - yFooter;
    if (height < minHeight) {
        height = minHeight;
    }
    var layout = {
        showlegend:true,
        legend:{orientation: "v" },
        hovermode:'closest',
        xaxis: { title: plottableData[xDataName].name },
        yaxis: { title: plottableData[yDataName].name },
        autosize:true,
        margin:20,
        width:width,
        height:height,
    };
    return layout;
}

function redrawPlot() {
    var layout = getLayout();
    var plotData = [];
    curPlottingNames = []; // fixme
    _.each(curPlottingNodes, function(node, name) {
        curPlottingNames.push(name);
        plotData.push(getPlotData(node));
    });
    Plotly.newPlot(thePlot, plotData, layout, 
        {displayLogo:false, displayModeBar: true});
    thePlot.on('plotly_click', function(data) {
        if (data.points.length > 0) {
            var idx = data.points[0].pointNumber;
            var track = data.points[0].data.node.tracks[idx];
            playTrack(track);
        }
    });

    thePlot.on('plotly_selected', function(data) {
        var trackList = [];
        _.each(data.points, function(point) {
            var plotName = curPlottingNames[point.curveNumber];
            var track = curPlottingNodes[plotName].tracks[point.pointNumber];
            trackList.push(track);
            curSelected.add(track.id);
        });
        $(".nstaging-tracks").text(curSelected.size);
        info("selected " + trackList.length + " tracks");
        $("#add-to-wip").enable();
    });
}

function clearPlot() {
    curPlottingNodes = {};
    redrawPlot();
}

function getDisplayType(getter, tracks) {
    if (tracks.length > 0) {
        var type =  typeof getter(tracks[0]);
        return type;
    } else {
        return "string";
    }
}

function showPlaylist(node) {
    if (theTrackTable == null) {
        return;
    }
    if (stagingIsVisible) {
        $('#the-track-list-tab').tab('show');
    }
    curNode = node;
    var nTracks = node.tracks.length;
    var nArtists = node.artists.size;
    playlistTitle("Your " + uname(node.name) + " tracks" );
    playlistSubtitle(nTracks + " tracks / " + nArtists + " artists");

    $("#tbl-param").text(node.label);
    if (node.tracks.length > maxTracksShown) {
        $("#gthe-track-table-truncated").show();
    } else {
        $("#gthe-track-table-truncated").hide();
    }
    showTracksInTable(theTrackTable, node.tracks, node.getter, node.label, false);
}

function showStagingList() {
    if (theStagingTable == null) {
        return;
    }
    curSelectedTracks = [];
    curSelected.forEach(function(tid) {
        curSelectedTracks.push(curTracks[tid]);
    });
    if (curSelectedTracks.length > 0) {
        $("#staging-full").show();
        $("#staging-empty").hide();
    } else {
        $("#staging-full").hide();
        $("#staging-empty").show();
    }
    if (curSelectedTracks > maxTracksShown) {
        $("#gthe-staging-table-truncated").show();
    } else {
        $("#gthe-staging-table-truncated").hide();
    }
    showTracksInTable(theStagingTable, curSelectedTracks, featGetter('popularity'), 'popularity', true);
}

function getStagingTracks() {
    var sortInfo = theStagingTable.getSortInfo();
    var out = [];

    if (sortInfo.sortedIndexes) {
        _.each(sortInfo.sortedIndexes, function(idx) {
            var track = curSelectedTracks[idx];
            if (curSelected.has(track.id)) {
                out.push(track);
            }
        });
    } else {
        _.each(curSelectedTracks, function(track) {
            if (curSelected.has(track.id)) {
                out.push(track);
            }
        });
    }
    return out;
}

function getInt(val) {
    return Math.round(val);
}

function getString(val) {
    return val.toString();
}

function getDate(val) {
    return val.format("YYYY&#8209;MM&#8209;DD");
}

function getPercent(val) {
    return getInt(val * 100);
}

function getDuration(val) {
    return getInt(val / 1000);
}

function showTracksInTable(table, tracks, getter, label, isStagingList) {
    var data = new google.visualization.DataTable();
    data.addColumn('string', 'sel');
    data.addColumn('string', '');
    data.addColumn('string', 'title');
    data.addColumn('string', 'artist');
    data.addColumn('string', 'top genre');
    data.addColumn('string', 'year');
    data.addColumn('string', 'added');
    data.addColumn('number', 'bpm');
    data.addColumn('number', 'nrgy');
    data.addColumn('number', 'dnce');
    data.addColumn('number', 'dB');
    data.addColumn('number', 'live');
    data.addColumn('number', 'val');
    data.addColumn('number', 'dur');
    data.addColumn('number', 'acous');
    data.addColumn('number', 'spch');
    data.addColumn('number', 'pop');

    data.setColumnProperty(0, {allowHTML: true});
    data.setColumnProperty(1, {allowHTML: true});

    if (tracks.length > maxTracksShown) {
        $(".truncated").show();
    } else {
        $(".truncated").hide();
    }


    // lets show:
    //  energy, loudness, acoustic, speech,
    // #    TITLE    ARTIST    RELEASE    BPM    ENERGY    DANCE    LOUD
    // VALENCE    LENGTH    ACOUSTIC    POP.

    var rows = [];
    _.each(tracks, function(track, i) {
        if (i >= maxTracksShown) {
            return;
        }
        var sel = $("<input class='track-select'>")
            .attr('type', 'checkbox')
            .attr('id', 'sel-' + track.id)
            .attr('title', 'select to add this track to the staging list');

        if (curSelected.has(track.id )) {
            sel.prop('checked', true);
        }

        var play;

        if (track.details.preview_url  != null) {
            play = $("<span class='track-play glyphicon glyphicon-play'>");
            play.attr('id', 'play-' + track.id);
        } else {
            play = $("<span>");
        }

        var row = [];
        row.push(sel.prop('outerHTML'));
        row.push(play.prop('outerHTML'));
        row.push(track.details.name);
        row.push(track.details.artists[0].name);
        row.push(track.feats.topGenre);
        row.push(getString(track.feats.year));
        row.push(getDate(track.feats.date_added));
        row.push(getInt(track.feats.tempo));
        row.push(getPercent(track.feats.energy));
        row.push(getPercent(track.feats.danceability));
        row.push(getInt(track.feats.loudness));
        row.push(getPercent(track.feats.liveness));
        row.push(getPercent(track.feats.valence));
        row.push(getDuration(track.feats.duration_ms));
        row.push(getPercent(track.feats.acousticness));
        row.push(getPercent(track.feats.speechiness));
        row.push(getInt(track.feats.popularity));
        rows.push(row);
    });
    data.addRows(rows);

    /*
    _.each(tracks, function(track, i) {
        data.setProperties(i, 0, {style: 'background-color:red;'});
    });
    */

    table.draw(data, {
        showRowNumber: true, 
        width: '100%', 
        page: 'disable', 
        allowHtml:true,
        cssClassNames: {
            headerRow: 'headerRow',
            tableCell: 'track-table-cell',
            headerCell: 'track-header-cell',
        },
    });
    table.data = data; // TBD hackity hack
    addEventHandlers($(table));
}

function addEventHandlers(table) {

    $('.track-select').off('change');
    $('.track-play').off('click');

    $('.track-select').each(function() {
        var tid = getTidFromElemId($(this).attr('id'));
        if (curSelected.has(tid)) {
            $(this).prop('checked', true);
        } else {
            $(this).prop('checked', false);
        }
    });

    $('.track-select').on('change', function(e) {
        var tid = getTidFromElemId(e.target.id);
        if ($(e.target).is(':checked')) {
            curSelected.add(tid);
        } else {
            curSelected.delete(tid);
        }
        var track = curTracks[tid];
        e.stopPropagation();
        $(".nstaging-tracks").text(curSelected.size);
        return false;
    });

    $('.track-play').each(function() {
        var tid = getTidFromElemId($(this).attr('id'));
        var track = curTracks[tid];
        if (isPlaying(track)) {
            $(this).addClass('glyphicon-pause').removeClass('glyphicon-play');
        }
    });

    $('.track-play').on('click', function(e) {
        var tid = getTidFromElemId(e.target.id);
        var elem = $(e.target);
        var track = curTracks[tid];

        $(".track-play").removeClass('glyphicon-pause').addClass('glyphicon-play');
        if  (isPlaying(track)) {
            stopTrack(track);
        } else {
            elem.removeClass('glyphicon-play').addClass('glyphicon-pause');
            playTrack(track);
        }
        e.stopPropagation();
        return false;
    });
}

function getTidFromElemId(elemId) {
    return elemId.split('-')[1];
}


function saveTracksToPlaylist(playlist, inputTracks) {
    var tracks = inputTracks.slice();
    function saveTracks() {
        var uris = [];

        while (tracks.length > 0 && uris.length < 100) {
            var track = tracks.shift();
            uris.push(track.details.uri);
        }

        var url = "https://api.spotify.com/v1/users/" + curUserID
            + "/playlists/" + playlist.id + "/tracks";
        var params = {
            uris:uris
        }
        callSpotify("POST", url, params, function(ok, results) {
            if (ok) {
                if (tracks.length > 0) {
                    saveTracks();
                } else {
                    info("playlist saved");
                }
            } else {
                error("Trouble adding tracks to playlist");
            }
        });
    }
    saveTracks();
}

function makeNode(name, label, filter, getter, sorter, plottable) {
    var node = {
        name:name,
        label:label,
        plottable:plottable,
        tracks:[],
        artists: new Set(),
        filter:filter,
        getter:getter,
        sorter:sorter
    };
    if (name in nodeMap) {
        console.log("WARNING, dup node", name);
    }
    nodeMap[name] = node;
    return node;
}

function savePlaylist() {
    var curTracks = getStagingTracks();
    if (curTracks.length > 0) {
        var name = $("#staging-playlist-name").text();
        info("saving " + name);
        var url = "https://api.spotify.com/v1/users/" + curUserID + "/playlists"
        callSpotify("POST", url, {name:name }, function(ok, results) {
            if (ok) {
                saveTracksToPlaylist(results, curTracks);
            } else {
                error("Trouble creating playlist");
            }
        })
    } else {
        info("no tracks to save");
    }
}

function updateViewOfTheWorld(quick) {
    var minTracksForSection = 3;
    var sidebar = $("#sidebar");
    sidebar.empty();
    var first = true;

    updateFavs();
    _.each(theWorld, function(bin) {
        var nodes = sortedNodes(bin.nodes);
        var head = $("<h4>").text(uname(bin.name));
        head.attr("data-toggle", "collapse");
        head.attr("data-target", "#" + nname(bin.name));
        sidebar.append(head);
        var ul = $("<ul class='playlist-list collapse in'>");
        ul.attr("id", nname(bin.name));
        sidebar.append(ul);
        _.each(nodes, function(node) {
            node.tracks = node.sorter(node.tracks);
            var tracks = node.tracks;
            if (tracks.length >= minTracksForSection) {
                var header = $("<li>").text(uname(node.name));
                var nArtists = node.artists.size;
                var stats = $("<span class='stats'>").text("(" + tracks.length +
                    " tracks / " + nArtists + " artists)");
                header.append(stats);
                if (!quick) {
                    header.on("click", function() {
                        plotPlaylist(node);
                        showPlaylist(node);
                    });
                    if (first) {
                        first = false;
                        showPlaylist(node);
                        plotPlaylist(node);
                    }
                } else {
                }
                ul.append(header);
            }
        });
    });

}

var plottableData = {
    energy: {
        name: "energy",
        min:0, max:1,
        getter:featGetterPercent('energy')
    },
    danceability: {
        name: "danceability",
        min:0, max:1,
        getter:featGetterPercent('danceability')
    },
    valence: {
        name: "valence",
        min:0, max:1,
        getter:featGetterPercent('valence')
    },
    duration: {
        name: "duration",
        min:0, max:1500,
        getter:featGetter('duration')
    },
    tempo: {
        name: "tempo",
        min:40, max:240,
        getter:featGetter('tempo')
    },
    anger: {
        name: "anger",
        min:0, max:1,
        getter:featGetterPercent('anger')
    },
    happiness:{
        name: "happiness",
        min:0, max:1,
        getter:featGetterPercent('happiness')
    },
    loudness:{
        name: "loudness",
        min:-30, max:0,
        getter:featGetter('loudness')
    },
    acousticness: {
        name: "acousticness",
        min:0, max:1,
        getter:featGetterPercent('acousticness')
    },
    liveness: {
        name: "live",
        min:0, max:1,
        getter:featGetterPercent('liveness')
    },
    speechiness: {
        name: "speechiness",
        min:0, max:1,
        getter:featGetterPercent('speechiness')
    },
    popularity: {
        name: "popularity",
        min:0, max:100,
        getter:featGetter('popularity')
    },
    age: {
        min:0, max:5000,
        name: "days-since-added",
        getter:featGetter('age')
    },
    year: {
        min:1950, max:2020,
        name: "release-year",
        getter:featGetter('year')
    },
};

function addPlotSelect(elem, defaultValue) {
    elem.empty();
    var keys = Object.keys(plottableData);
    keys.sort();
    _.each(keys, function(key) {
        var param = plottableData[key];
        var option = $("<option>");
        option.text(param.name);
        option.attr('value', key);
        elem.append(option);
    });
    elem.val(defaultValue);
    elem.on('change', redrawPlot);
}

function nname(s) {
    return s.replace(/ /g, '_');
}

function uname(s) {
    return s.replace(/_/g, ' ');
}

function sortedNodes(nodes) {
    nodes.sort(function(a,b) {
        if (a.name == '(unclassified genre)') {
            return 1;
        } else if (b.name == '(unclassified genre)') {
            return -1;
        } else {
            if (a.tracks.length > b.tracks.length) {
                return -1;
            } else if (a.tracks.length < b.tracks.length) {
                return 1;
            } else {
                return 0;
            }
        }
    });
    return nodes;
}

function featGenreFilter(genre) {
    return function(track) {
        return track.feats.genres.has(genre);
    };
}


function featGenreGetter(genre) {
    return function(track) {
        var glist = Array.from(track.feats.genres);
        return glist.join(', ');
    };
}

function featGenreSorter(genre) {
    return function(tracks) {
        tracks.sort(function(a,b) {
            if (a.feats.genres.size > b.feats.genres.size) {
                return 1;
            } else if (a.feats.genres.size < b.feats.genres.size) {
                return -1;
            } else {
                return b.feats.popularity - a.feats.popularity;
            }
        });
        return tracks;
    };
}

function featSourceFilter(source) {
    return function(track) {
        return track.feats.source == source;
    };
}

function featSourceGetter(source) {
    return function(track) {
        return track.feats.source;
    };
}

function featSorter(param, reverse) {
    return function(tracks) {
        tracks.sort(function(a,b) {
            if (a.feats[param] > b.feats[param]) {
                return 1;
                curPlottingNames.push(node.name);
            } else if (a.feats[param] < b.feats[param]) {
                return -1;
            } else {
                return 0;
            }
        });
        if (reverse) {
            tracks.reverse();
        }
        return tracks;
    };
}

function featGetter(param) {
    return function(track) {
        return track.feats[param];
    };
}

function featGetterInt(param) {
    return function(track) {
        return Math.round(track.feats[param]);
    };
}

function featGetterPercent(param) {
    return function(track) {
        return Math.round(100 * track.feats[param]);
    };
}

function featGetterBool(param, true_val, false_val) {
    return function(track) {
        return track.feats[param] ? true_val : false_val;
    };
}

function featBoolFilter(param, state) {
    return function(track) {
        return 'feats' in track &&
                track.feats[param] == state;
    };
}
function featMusicFilter(param, low, high) {
    return function(track) {
        return 'feats' in track &&
                track.feats.speechiness < .8 &&
                track.feats[param] >= low &&
                track.feats[param] <= high;
    };
}

function featMissingFilter(param) {
    return function(track) {
        return (! ('energy' in track.feats));
    };
}

function featFilter(param, low, high) {
    return function(track) {
        return 'feats' in track &&
                track.feats[param] >= low &&
                track.feats[param] <= high;
    };
}

function applyFilter(tracks, filt) {
    var out = [];
    _.each(tracks, function(track) {
        if (filt(track)) {
            out.push(track);
        }
    });
    return out;
}


function getYearForTrack(track) {
    var year = -1;
    if (track.details.album_id in curAlbums) {
        var album = curAlbums[track.details.album_id];
        if ('release_date' in album) {
            var date = album.release_date;
            if (date.length >=4) {
                var syear = date.substring(0,4);
                year = parseInt(syear);
            }
        }
    }
    return year;
}

function getGenresForTrack(track) {
    var genres = [];
    var albumId = track.details.album_id;
    if (albumId in curAlbums) {
        var album = curAlbums[albumId];
        _.each(album.genres, function(g) {
            genres.push(g);
        });
    }

    _.each(track.details.artists, function(artist) {
        if (artist.id in curArtists) {
            var detailedArtist = curArtists[artist.id];
            _.each(detailedArtist.genres, function(genre) {
                genres.push(genre);
            });
        }
    });
    if (genres.length == 0) {
        genres.push('(unclassified genre)');
    }
    return genres;
}

function isGoodGenre(genre) {
    var lgenre = genre.toLowerCase();
    for (var i = 0; i < skipGenrePhrases.length; i++) {
        var phrase = skipGenrePhrases[i];
        if (lgenre.indexOf(phrase) != -1) {
            return false;
        }
    }
    return true;
}

function error(msg) {
    info(msg);
}

function info(msg) {
    $("#info").text(msg);
}

function linfo(msg) {
    $("#linfo").text(msg);
}

function authorizeUser() {
    var scopes = 'user-library-read playlist-modify-public';
    var url = 'https://accounts.spotify.com/authorize?client_id=' + SPOTIFY_CLIENT_ID +
        '&response_type=token' +
        '&show_dialog=false' +
        '&scope=' + encodeURIComponent(scopes) +
        '&redirect_uri=' + encodeURIComponent(SPOTIFY_REDIRECT_URI);
    document.location = url;
}

function parseArgs() {
    var hash = location.hash.replace(/#/g, '');
    var all = hash.split('&');
    var args = {};
    _.each(all, function(keyvalue) {
        var kv = keyvalue.split('=');
        var key = kv[0];
        var val = kv[1];
        args[key] = val;
    });
    return args;
}

function callSpotify(type, url, json, callback) {
    $.ajax(url, {
        type: type,
        data: JSON.stringify(json),
        dataType: 'json',
        headers: {
            'Authorization': 'Bearer ' + accessToken,
            'Content-Type': 'application/json'
        },
        success: function(r) {
            callback(true, r);
        },
        error: function(r) {
            // 2XX status codes are good, but some have no
            // response data which triggers the error handler
            // convert it to goodness.
            if (r.status >= 200 && r.status < 300) {
                callback(true, r);
            } else {
                callback(false, r);
            }
        }
    });
}


function getSpotifyP(url, data) {
    return new RSVP.Promise(function(resolve, reject) {
        var curRetry = 0;
        var maxRetries = 10;
        function go() {
          $.ajax(url, {
              dataType: 'json',
              data: data,
              headers: {
                  'Authorization': 'Bearer ' + accessToken
              },
              beforeSend : function () {
                  // console.log("GET: " + this.url);
              },
              success: function(data) {
                  resolve(data);
              },
              error: function(jqXHR, textStatus) {
                  if (jqXHR.status >= 200 && jqXHR.status < 300) {
                      resolve(jqXHR);
                  } else if (jqXHR.status == 401) {
                      window.location = 'index.html';
                  } else if (jqXHR.status >= 500 && jqXHR.status < 600) {
                    if (curRetry++ < maxRetries) {
                        console.log('500 retry', curRetry, jqXHR.status);
                        setTimeout(go, 500);
                    } else {
                        console.log('500 error', jqXHR);
                        reject(textStatus + " after " + maxRetries + " retries");
                    }
                  } else if (jqXHR.status == 429) {
                      console.log("429 status", jqXHR);
                      var retry = 2000;
                      var retryAfter = jqXHR.getResponseHeader("Retry-After");
                      console.log("retryAfter is", retryAfter);

                      if (retryAfter) {
                          retry = parseInt(retryAfter, 10) * 1000;
                      }
                      if (retry < 1000) {
                          retry = 1000;
                      }
                      console.log("retry", retry);
                      if (curRetry++ < maxRetries) {
                          console.log('429 retry', curRetry);
                          setTimeout(go, retry + curRetry * retry);
                      } else {
                          console.log('429 error', jqXHR);
                          reject(textStatus + " after " + maxRetries + " retries");
                      }
                    } else {
                      reject(textStatus);
                  }
              }
          });
      }
      go();
    });
}


function fetchCurrentUserProfile() {
    var url = 'https://api.spotify.com/v1/me';
    return getSpotifyP(url, null);
}


function isPlaying(track) {
    return (track === nowPlaying) && !audio.get(0).paused;
}

function playTrack(track) {
    if (track != nowPlaying) {
        audio.get(0).pause();
        audio.attr('src', track.details.preview_url);
        audio.get(0).play();
        nowPlaying = track;
    } else {
        stopTrack();
    }
}

function stopTrack() {
    audio.get(0).pause();
    nowPlaying = null;
    $(".playing").removeClass("playing");
}


function collectAudioAttributes(tracks) {
    var trackIds = [];
    _.each(tracks, function(track) {
        trackIds.push(track.id);
    });

    return getSpotifyP("https://api.spotify.com/v1/audio-features",
        { ids: trackIds.join(',')})
        .then(function(results) {
          _.each(results.audio_features, function(audio_feature) {
              if (audio_feature) {
                  var track = curTracks[audio_feature.id];
                  //track.audio_feature = audio_feature;
                  _.each(audio_feature, function(val, name) {
                      track.feats[name] = val;
                  });
                  track.feats.sadness=  (1 - audio_feature.energy) * (1 - audio_feature.valence);
                  track.feats.happiness = audio_feature.energy * audio_feature.valence;
                  track.feats.anger = audio_feature.energy * (1 - audio_feature.valence);
              }
          });
          return results;
    });
}

function collectArtistAttributes(tracks) {
    var aids = [];
    var maxArtistsPerCall = 50;
    var deferred = RSVP.defer();

    function getNextArtists() {
        var nextAids = getNextBatch(aids, maxArtistsPerCall);
        if (nextAids.length > 0) {
            return getSpotifyP("https://api.spotify.com/v1/artists", { ids: nextAids.join(',')})
              .then(function(results) {
                _.each(results.artists, function(artist) {
                    if (artist != null  && 'id' in artist) {
                    curArtists[artist.id] = {
                        genres:artist.genres,
                        name:artist.name,
                        count: 1
                    }
                  }
                });
                getNextArtists();
            })
            .catch(function(error) {
                deferred.reject(error);
            });
        }  else {
            deferred.resolve(curArtists);
        }
    }

    var aidsSet = new Set();
    _.each(tracks, function(track) {
        _.each(track.details.artists, function(artist) {
            if (! (artist.id in curArtists)) {
                aidsSet.add(artist.id);
            } else {
                curArtists[artist.id].count += 1;
                var count = curArtists[artist.id].count;
                if (count > topArtistCount) {
                    topArtistCount = count;
                    topArtistName = curArtists[artist.id].name;
                }
            }
        });
    });
    aids = Array.from(aidsSet);
    getNextArtists();
    return deferred.promise;
}


function collectAlbumAttributes(tracks) {
    var maxAlbumsPerCall = 20;
    var aids = [];
    var deferred = RSVP.defer();

    function getNextAlbums() {
        var nextAids = getNextBatch(aids, maxAlbumsPerCall);
        if (nextAids.length > 0) {
            getSpotifyP("https://api.spotify.com/v1/albums", { ids: nextAids.join(',')})
            .then(function(results) {
                _.each(results.albums, function(album) {
                    if (album != null && 'id' in album) {
                    curAlbums[album.id] = {
                        release_date:album.release_date,
                        genres:album.genres,
                    };
                  }
                });
                getNextAlbums();
            })
            .catch(function(error) {
              deferred.reject(error);
            });
        } else {
          deferred.resolve(curAlbums);
        }
    }

    var aidSet = new Set();
    _.each(tracks, function(track) {
        if (! (track.details.album_id in curAlbums)) {
            aidSet.add(track.details.album_id);
        }
    });
    aids = Array.from(aidSet);
    getNextAlbums();
    return deferred.promise;
}

function getNextBatch(list, nitems) {
    var out = [];
    while (list.length > 0 && out.length  < nitems) {
        out.push(list.shift());
    }
    return out;
}


var trackTextQueue = [];
var showingTracks = false;
var tt = $("#tiny-track");

function showTracks(prefix, tracks) {
    _.each(tracks, function(track) {
        var text = prefix + " - " + track.details.artists[0].name
                + " - " +  track.details.name;
        trackTextQueue.push(text);
    });
}

function showTracksUpdater() {
    if (showingTracks) {
        if (trackTextQueue.length > 0) {
            var text = trackTextQueue.shift();
            tt.text(text);
            //tt.text(trackTextQueue.length + " " + text);
        }
        if (trackTextQueue.length > 0) {
            setTimeout(showTracksUpdater, 40);
        } else {
            setTimeout(showTracksUpdater, 300);
        }
    } else {
        tt.text("");
    }
}

function startShowingTracks() {
    showingTracks = true;
    showTracksUpdater();
}

function stopShowingTracks() {
    showingTracks = false;
}

function getTracksFromAPI(source, uri) {
    var deferred = RSVP.defer();

    function go(offset) {
        var params = {
            limit:50,
            market:'from_token',
            offset:offset,
        }
        getSpotifyP(uri, params)
        .then(
          function(results) {
            var now = moment();
            var tracks = [];
            var loadedTracks = [];
            _.each(results.items, function(item) {
                if (!item.is_local && item.track && ('id' in item.track)) {
                    item.track.added_at = item.added_at;
                    item.track.date_added = moment(item.added_at);
                    item.track.age = moment.duration(now.diff(item.track.date_added)).asDays();
                    var track = {
                        id:item.track.id,
                        feats: {
                            date_added:moment(item.added_at),
                            age:moment.duration(now.diff(item.track.date_added)).asDays(),
                            explicit:item.track.explicit,
                            duration_ms:item.track.duration_ms,
                            popularity:item.track.popularity,
                            source:source,
                            count:1,
                        },
                        details: {
                            name:item.track.name,
                            album_id:item.track.album.id,
                            uri:item.track.uri,
                            preview_url:item.track.preview_url,
                            artists:tinyArtists(item.track.artists),
                        }
                    }
                    if (track.id in curTracks) {
                        curTracks[track.id].feats.count += 1;
                        var count = curTracks[track.id].feats.count;
                        if (count > topTrackCount) {
                            topTrackCount = count;
                            topTrackName = item.track.name;
                        }
                    } else {
                        var ntrack = loadTrack(track.id);
                        if (ntrack != null) {
                            curTracks[track.id] = ntrack;
                            curTracks[track.id].feats.count = 1;
                            loadedTracks.push(ntrack);
                        } else {
                            tracks.push(track);
                            curTracks[track.id] = track;
                        }
                    } 
                }
            });
            showTracks(source, tracks);
            refreshHeader();
            totalTracks = results.total;

            collectAudioAttributes(tracks)
            .then( function() {
                return collectArtistAttributes(tracks);
            })
            .then( function() {
                return collectAlbumAttributes(tracks);
            })
            .then(function() {
              addTracks(tracks);
              filterTracks(tracks);
              filterTracks(loadedTracks);
              if (!abortLoading && results.offset + results.items.length < results.total) {
                go(results.offset + results.items.length);
              } else {
                refreshTheWorld(true);
                deferred.resolve(curTracks);
              }
            });
          })
          .catch(function(error) {
            deferred.reject(error);
          });
      }
    go(0);
    return deferred.promise;
}

function tinyArtists(artists) {
    var tartists = [];
    _.each(artists, function(artist) {
        var tartist = {
            id:artist.id,
            name:artist.name,
        }
        tartists.push(tartist);
    });
    return tartists;
}

function getSavedTracks() {
    startShowingTracks();
    $("#lplaylist-name").text("Your Saved Tracks");
    getTracksFromAPI("Your Saved tracks", "https://api.spotify.com/v1/me/tracks")
    .then(function(results) {
    })
    .catch(function(results){
      console.log("GST catch " + results);
    })
    .finally(function() {
        stopShowingTracks();
        refreshTheWorld(false);
        $("#loaded").show();
        $("#loading").hide();
    });
}

function getAllMusic() {
    startShowingTracks();
    $("#lplaylist-name").text("Your Saved Tracks");
    getTracksFromAPI("Your Saved Tracks", "https://api.spotify.com/v1/me/tracks")
    .then(function(results) {
        getMusicFromPlaylists(true);
    });
}

function getMusicFromPlaylists(allPlaylists) {
    // get all the tracks from all the 'own'
    // playlists of the user, up to a maximum amount
    var deferred = RSVP.defer();

    function getMyPlaylists(offset) {
        var params = { limit:50, offset:offset };
        getSpotifyP("https://api.spotify.com/v1/me/playlists", params)
        .then(function(results) {
            if (results) {
                var outstandingPlaylists = [];
                var count = results.offset + results.items.length;
                totalPlaylists = results.total;
                _.each(results.items, function(playlist) {
                    outstandingPlaylists.push(playlist);
                });
                loadPlaylists(outstandingPlaylists, allPlaylists)
                .then(function() {
                    if (!abortLoading && count < results.total) {
                        getMyPlaylists(count);
                    } else {
                      deferred.resolve(outstandingPlaylists);
                    }
                });
            } else {
                deferred.reject(new Error("can't get your playlist"));
            }
        })
        .catch(function(error) {
          deferred.reject(error);
        });
    }

    startShowingTracks();
    getMyPlaylists(0);

    deferred.promise.then( function() {
    })
    .catch(function(theError) {
        error("trouble, " + theError);
    })
    .finally(function() {
        stopShowingTracks();
        refreshTheWorld(false);
        $("#loaded").show();
        $("#loading").hide();
    });
}

var quickMode = false;

function loadPlaylists(playlists, allPlaylists) {
    var deferred = RSVP.defer();

    function fetchNextPlaylist() {
        if (!abortLoading && playlists.length > 0) {
            processedPlaylists += 1;
            var playlist = playlists.shift();
            if (quickMode && processedPlaylists > 100) {
                return deferred.resolve(playlists);
            }
            if (isGoodPlaylist(playlist, allPlaylists)) {
                $("#lplaylist-name").text(playlist.name + " (" + playlist.tracks.total + " tracks)");
                getPlaylistTracks(playlist)
                  .then(function() {
                    fetchNextPlaylist();
                  })
                  .catch(function(error) {
                    console.log("trouble loading playlist", playlist);
                    fetchNextPlaylist();
                    // return deferred.reject(error);
                  })
            } else {
                fetchNextPlaylist();
            }
        } else {
            return deferred.resolve(playlists);
        }
    }
    fetchNextPlaylist();
    return deferred.promise;
}

function isGoodPlaylist(playlist, allPlaylists) {
    if (allPlaylists || playlist.owner.id == curUserID) {
        if (playlist.tracks.total > 0) {
            return true;
        }
    }
    return false;
}

function getPlaylistTracks(playlist) {
    var uri = playlist.uri;
    if (isValidPlaylistUri(uri)) {
        var playlistID = getPlaylistPid(uri);
        //var url = "https://api.spotify.com/v1/users/"
        //    + userID + "/playlists/" + playlistID + "/tracks";
        var url = "https://api.spotify.com/v1/playlists/" + playlistID + "/tracks";
        return getTracksFromAPI(playlist.name, url);
    } else {
        var deferred = RSVP.defer();
        deferred.reject(new Error("bad playlist URI"));
        return deferred.promise;
    }
}

function getPlaylistFromURI(name, uri) {
    startShowingTracks();
    var playlist = {
        name:name,
        uri:uri
    };
    getPlaylistTracks(playlist)
    .finally(function() {
        stopShowingTracks();
        refreshTheWorld(false);
        $("#loaded").show();
        $("#loading").hide();
    });
}

function isLocalHost() {
    return window.location.host.indexOf('localhost') >= 0;
}

function isValidPlaylistUri(uri) {
    var fields = uri.split(':');
    if (fields.length == 3) {
        if (fields[0] != 'spotify' || fields[1] != 'playlist') {
            return false;
        }
    } else if (fields.length == 5) {
        if (fields[0] != 'spotify' || fields[3] != 'playlist') {
            return false;
        }
    } else {
        return False;
    }
    return true;
}

function getPlaylistPid(uri) {
    var fields = uri.split(':');
    if (fields.length == 3) {
        return fields[2];
    } else if (fields.length == 5) {
        return fields[4];
    } 
    return null;
}


function saveInfo(params) {
    localStorage.setItem("info", JSON.stringify(params));
}

function getInfo(params) {
    var item = localStorage.getItem("info");
    return JSON.parse(item);
}

function go() {
    $('.err-txt').text("");
    var type = $("#collection-type").val();
    var params = {
        "type": type,
    }

    if (type == "playlist") {
        params.uri = $("#uri-text").val();
    }
    saveInfo(params);
    authorizeUser();
}

function goAll() {
    $('.err-txt').text("");
    var params = {
        "type": "all",
    }
    saveInfo(params);
    authorizeUser();
}

function normalizeUri(uri) {
    uri = uri.replace("https://open.spotify.com", 'spotify');
    uri = uri.replace("https://play.spotify.com", 'spotify');
    uri = uri.replace(/\//g, ':');
    return uri;
}

function stopLoading() {
    console.log('stop loading');
    abortLoading = true;
    linfo("Stopping ... hang on ...");
}

function goPlaylist() {
    $('.err-txt').text("");
    var uri = normalizeUri($("#uri-text").val());
    if (isValidPlaylistUri(uri)) {
        var params = {
            "type": "playlist",
            "uri": uri
        }
        saveInfo(params);
        authorizeUser();
    } else {
        $('.err-txt').text("That's not a playlist URI");
    }
}

function setProgress(percent) {
  progressBar.css('width', percent+'%').attr('aria-valuenow', percent);
}

function initTables() {
    theTrackTable = new google.visualization.Table(document.getElementById('gthe-track-table'));
    google.visualization.events.addListener(theTrackTable, 'ready', function(e) {
    });

    google.visualization.events.addListener(theTrackTable, 'select', function(e) {
    });

    function selectAllHandler(table, props) {
        if (props.column == 0) {
            $(table).find(".track-select").each(function() {
                $(this).prop('checked', props.ascending);
                var id = $(this).attr('id');
                var tid = getTidFromElemId(id);
                if (props.ascending) {
                    curSelected.add(tid);
                } else {
                    curSelected.delete(tid);
                }
            });
            $(".nstaging-tracks").text(curSelected.size);
        } 
    }

    google.visualization.events.addListener(theTrackTable, 'sort', function(props) {
        selectAllHandler("#gthe-track-table", props);
        addEventHandlers($(theTrackTable));
    });
    theStagingTable = new google.visualization.Table(document.getElementById('gthe-staging-table'));
    google.visualization.events.addListener(theStagingTable, 'sort', function(props) {
        selectAllHandler("#gthe-staging-table", props);
        addEventHandlers($(theStagingTable));
    });
}

function initPlot() {
    addPlotSelect($("#select-xaxis"), "energy");
    addPlotSelect($("#select-yaxis"), "loudness");
    addPlotSelect($("#select-size"), "popularity");

    $("#plot-clear").on("click", function() {
        clearPlot();
    });

    window.onresize = function() {
        redrawPlot();
    };

    clearPlot();
}

$(document).ready(
    function() {
        if (isLocalHost()) {
            SPOTIFY_REDIRECT_URI = LOCAL_SPOTIFY_REDIRECT_URI;
        }
        var args = parseArgs();
        window.location.hash = "";

        $("#collection-type").on("change", function() {
            var type = $("#collection-type").val();
            if (type == 'playlist') {
                $("#uri-prompt").show(200);
            } else {
                $("#uri-prompt").hide(200);
            }
        });

        $(".max-shown").text(maxTracksShown);
        $(".work").hide();
        if ('error' in args) {
            error("Sorry, I can't read your music collection from Spotify without authorization");
            $("#go").show();
            $("#go").on('click', function() {
                go();
            });
        } else if ('access_token' in args) {
            thePlot = $("#the-plot").get(0);
            $(".work").show();
            $("#intro").hide();
            accessToken = args['access_token'];
            $("#stop-loading").on('click', function() {
                stopLoading();
            });
            $('#staging-playlist-name').editable({
                mode:'popup',
                placement:'right'
            });

            $("#save-button").on("click", function() {
                savePlaylist();
            });
            $("#staging-tab").on('shown.bs.tab', function() {
                stagingIsVisible = true;
                showStagingList();
            });
            $("#staging-tab").on('hidden.bs.tab', function() {
                stagingIsVisible = false;
                showStagingList();
            });
            google.charts.load('current', {'packages':['table']});
            google.charts.setOnLoadCallback(initTables);


            initPlot();

            fetchCurrentUserProfile()
            .then(function(user) {
                if (user) {
                    curUserID = user.id;
                    $("#who").text(user.id);
                    var info = getInfo();
                    var curType = info.type;
                    curTypeName = $("#collection-type option[value='" + curType +"']").text()
                    $("#section-title").text(curTypeName);
                    if (info.type == "saved") {
                        getSavedTracks();
                    } else if (info.type == "added") {
                        getMusicFromPlaylists(false);
                    } else if (info.type == "playlist") {
                        getPlaylistFromURI("Your Playlist", info.uri);
                    } else if (info.type == "follow") {
                        getMusicFromPlaylists(true);
                    }  else if (info.type == "all") {
                        getAllMusic();
                    } else {
                        console.log("unexpected type", info.type);
                    }
                } else {
                    error("Trouble getting the user profile");
                }
            });
        } else {
            $("#go").show();
            $("#go").on('click', function() {
                go();
            });
        }
    }
);

function saveTrack(track) {
    return ;
    var key = track.id;
    localStorage.setItem(key, JSON.stringify(track));
}

function loadTrack(id) {
    return null;
    var strack = localStorage.getItem(id);
    if (strack) {
        var track = JSON.parse(strack);
        return track;
    }
    return strack;
}

</script>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-3675615-27']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type =
'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' :
'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0];
s.parentNode.insertBefore(ga, s);
  })();

</script>

</body>
</html>
